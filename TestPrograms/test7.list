    // Load values into registers for arithmetic operations
    LLB R1, 0x10      // R1 = 0x0010
    LHB R1, 0x00      
    LLB R2, 0x20      // R2 = 0x0020
    LHB R2, 0x00
    LLB R3, 0x05      // R3 = 0x0005
    LHB R3, 0x00
    LLB R4, 0xFF      // R4 = 0x00FF
    LHB R4, 0x00
    LLB R5, 0x01      // R5 = 0x0001
    LHB R5, 0x00
    LLB R6, 0x04      // R6 = 0x0004
    LHB R6, 0x00
    LLB R7, 0x00      // R7 = 0x0000
    LHB R7, 0x00

    // Memory-to-Memory Forwarding (LW followed by SW)
    LW  R8, R1, 4  // Load memory at address R1 + 0x04 into R8
    SW  R8, R1, 8  // Store R8 at address R1 + 0x08 (forwarding)

    // Arithmetic operations
    ADD R9, R1, R2    // R9 = R1 + R2
    SUB R10, R2, R3   // R10 = R2 - R3
    PADDSB R11, R9, R10 // Packed add signed bytes

    // Bitwise and Shift operations
    SLL R12, R9, 1   // Logical shift left by 1
    SRA R13, R10, 1  // Arithmetic shift right by 1
    ROR R14, R12, 4  // Rotate right by 4

    // Reduction Unit (RED)
    RED R15, R14, R13 // Complex reduction operation

    // Branch and Jump tests
    PCS R0           // Save PC in R0 (for testing)
    B 011, branch1    // Branch if Less Than (N=1)
    BR 111, R0       // Unconditional jump to saved PC (loop)

    // Hazard Tests
    ADD R8, R9, R8   // Dependent on forwarded result from LW
    SUB R9, R8, R4   // Dependent on previous ADD
    SLL R10, R9, R5  // Dependent on previous SUB

    // Test forwarding and hazards across instructions
    LW  R11, R2, 0x02  // Load from memory (testing mem-to-mem hazard)
    SW  R11, R3, 0x06  // Store to memory (forwarded result)
    PADDSB R12, R11, R8 // Test packed add with forwarded result

    // Branch target
branch1:
    ADD R13, R7, R7   // R13 = 0 (verification)
    PCS R14           // Save PC in R14 for check
    HLT               // End of program
