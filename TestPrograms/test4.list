    // Initialize registers
    LLB R1, 0x05      // R1 = 0x0005
    LLB R2, 0x03      // R2 = 0x0003

    // Data Hazard Test (Forwarding)
    ADD R3, R1, R2    // R3 = R1 + R2 (0x0005 + 0x0003 = 0x0008)
    SUB R4, R3, R1    // R4 = R3 - R1 (0x0008 - 0x0005 = 0x0003)
    XOR R5, R4, R2    // R5 = R4 ^ R2 (0x0003 ^ 0x0003 = 0x0000)

    // Load-Use Hazard
    LLB R6, 0x20      // R6 = 0x0020 (Memory address)
    SW R3, R6, 0      // Store R3 (0x0008) at memory[0x0020]
    LW R7, R6, 0      // Load R7 from memory[0x0020]
    ADD R8, R7, R1    // Use loaded value immediately (testing load-use hazard)

    // Branching Hazard (Control Hazard)
    SUB R9, R1, R2    // R9 = R1 - R2 (0x0005 - 0x0003 = 0x0002)
    B 001, BRANCH1    // Branch if Equal (Z = 1) → should not branch

    // This section should execute if the branch was not taken
    ADD R10, R1, R9   // R10 = R1 + R9 (0x0005 + 0x0002 = 0x0007)

BRANCH1:
    SUB R11, R1, R1   // R11 = R1 - R1 (0x0000)
    B 011, END        // Branch if Less Than (N = 1) → should not branch

    // Forwarding with Branches
    ADD R12, R4, R5   // R12 = R4 + R5 (0x0003 + 0x0000 = 0x0003)
    B 000, BRANCH2    // Branch if Not Equal (Z = 0) → should branch

    // Unreachable if branch taken
    ADD R13, R12, R1  // Shouldn't execute

BRANCH2:
    ADD R14, R12, R2  // R14 = R12 + R2 (0x0003 + 0x0003 = 0x0006)

END:
    PCS R15           // Store PC in R15 to verify correctness
    HLT               // Halt execution
