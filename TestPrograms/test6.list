/////////////////////////////////////////////////////
// Array Summation and Averaging Program            //
// Uses a loop to sum an array and calculate the    //
// average, demonstrating various instruction types //
// and hazard management (forwarding, stalls).      //
/////////////////////////////////////////////////////

// Initialize registers and array base address
LLB R1, 0x05      // Loop counter (R1 = 5 elements)
LLB R2, 0x20      // Base address of the array (R2 = 0x0020)
LLB R3, 0x00      // Sum accumulator (R3 = 0x0000)
LLB R4, 0x05      // Constant: 5 (for averaging)
LLB R5, 0x01      // Increment value (R5 = 1)
LLB R6, 0x01      // Increment value (R6 = 1)


// Load array values into memory (initialization)
LLB R6, 0x03      // Array element 1
SW R6, R2, 0      // Store 0x0003 at memory[0x0020]
LLB R6, 0x07      // Array element 2
SW R6, R2, 1      // Store 0x0007 at memory[0x0022]
LLB R6, 0x0A      // Array element 3
SW R6, R2, 2      // Store 0x000A at memory[0x0024]
LLB R6, 0x02      // Array element 4
SW R6, R2, 3      // Store 0x0002 at memory[0x0026]
LLB R6, 0x04      // Array element 5
SW R6, R2, 4      // Store 0x0004 at memory[0x0028]

// Loop to sum the array elements
SUM_LOOP:
    LW R7, R2, 0      // Load array element (memory[R2])
    ADD R3, R3, R7    // Accumulate sum in R3
    ADD R2, R2, R6    // Move to next element (increment address by 2)
    ADD R6, R6, R5    // Move to next element (increment value by 1)
    SUB R1, R1, R5    // Decrement loop counter
    B 000, SUM_LOOP   // Branch if Not Equal (Z = 0) - Loop back if R1 != 0

// Calculate average (sum / 5)
SLL R3, R3, 2      // Multiply sum by 4 (shift left by 2)
ADD R3, R3, R3     // Multiply sum by 5 (4 + 1)
SRA R3, R3, 3      // Divide by 8 (shift right by 3) to approximate average

// Reduction operation (dummy)
RED R8, R3, R0     // Reduce R3, store in R8 (R0 as dummy operand)

// Shift and Rotate Operations
SLL R9, R3, 1      // Logical left shift (R9 = R3 << 1)
SRA R10, R3, 2     // Arithmetic right shift (R10 = R3 >> 2)
ROR R11, R3, 3     // Rotate right (R11 = R3 rotated right by 3)

// Parallel Addition (example usage)
PADDSB R12, R9, R10 // Parallel Add Signed Bytes (R12 = R9 + R10)

// Test branch for equality (should not branch)
SUB R13, R4, R5    // R13 = 5 - 1 = 4
B 001, BRANCH_SKIP // Branch if Equal (Z = 1) â†’ should not branch

// Code to skip if the branch was taken
ADD R14, R3, R4    // R14 = Sum + 5 (should execute if branch not taken)

BRANCH_SKIP:
PCS R15            // Store PC in R15 to verify correctness
HLT                // Halt execution
