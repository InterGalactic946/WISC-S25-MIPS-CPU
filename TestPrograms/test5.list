// Program to Test Various Instructions

////////////////////////////////////////////////////////
// Initialize Data in Memory                          //
////////////////////////////////////////////////////////
LLB R1, 0x0E      // R1 = 0x000E (for SW/LW test)
LLB R2, 0x06      // R2 = 0x0006
LLB R3, 0xFF      // R3 = 0x00FF (for signed byte addition)
LLB R4, 0x08      // R4 = 0x0008 (Shift amount)
LLB R5, 0x20      // R5 = 0x0020 (Memory address)

////////////////////////////////////////////////////////
// Memory-to-Memory Forwarding (LW followed by SW)     //
////////////////////////////////////////////////////////
LW R6, R5, 0      // Load R6 from memory[0x0020] (initial value)
SW R6, R5, 0      // Store R6 back to memory[0x0020]

////////////////////////////////////////////////////////
// Store Stall with Data Dependency                    //
////////////////////////////////////////////////////////
LW R7, R5, 0      // Load R7 from memory[0x0020] (initial value)
ADD R7, R7, R2    // R7 = R7 + R2 (0x0006 + 0x0006 = 0x000C)
SW R7, R5, 0      // Store R7 to memory[0x0020]

////////////////////////////////////////////////////////
// Arithmetic Instructions                            //
////////////////////////////////////////////////////////
ADD R8, R1, R2    // R8 = R1 + R2 (0x000E + 0x0006 = 0x0014)
SUB R9, R8, R2    // R9 = R8 - R2 (0x0014 - 0x0006 = 0x000E)
MUL R10, R1, R2   // R10 = R1 * R2 (0x000E * 0x0006 = 0x0054)
DIV R11, R10, R2  // R11 = R10 / R2 (0x0054 / 0x0006 = 0x000E)

////////////////////////////////////////////////////////
// Logical Instructions                               //
////////////////////////////////////////////////////////
AND R12, R8, R9   // R12 = R8 & R9 (0x0014 & 0x000E = 0x0004)
OR R13, R8, R9    // R13 = R8 | R9 (0x0014 | 0x000E = 0x001E)
XOR R14, R8, R9   // R14 = R8 ^ R9 (0x0014 ^ 0x000E = 0x001A)
NOT R15, R1       // R15 = ~R1 (0xFFF1)

////////////////////////////////////////////////////////
// Shift and Rotate Instructions                       //
////////////////////////////////////////////////////////
SLL R1, R1, R4    // R1 = R1 << 8  (0x000E << 8 = 0x0E00)
SRA R2, R1, R4    // R2 = R1 >> 8  (0x0E00 >> 8 = 0x000E)
ROR R3, R1, R4    // R3 = R1 ror 8 (0x0E00 -> 0x000E)

////////////////////////////////////////////////////////
// Reduction and Parallel Addition                     //
////////////////////////////////////////////////////////
RED R6, R1, R2, R3  // R6 = Reduce(R1, R2, R3) - Custom Reduction
PADDSB R7, R3, R3  // R7 = Parallel signed add of R3 and R3

////////////////////////////////////////////////////////
// Branch Instructions                                 //
////////////////////////////////////////////////////////
LLB R1, 0x01      // R1 = 0x0001 (for branch condition)
ADD R8, R1, R1    // R8 = R1 + R1 (0x0001 + 0x0001 = 0x0002)

// Branch Equal (Z = 1)
SUB R8, R8, R8    // Zero out R8
B 001, EQ_LABEL   // Branch if Equal (Z = 1) - Should Branch

// Branch Greater Than (Z = N = 0)
ADD R8, R1, R1    // R8 = R1 + R1 (0x0001 + 0x0001 = 0x0002)
B 010, GT_LABEL   // Branch if Greater Than - Should Branch

// Branch Less Than (N = 1)
SUB R8, R1, R2    // R8 = R1 - R2 (0x0001 - 0x000E = -13)
B 011, LT_LABEL   // Branch if Less Than - Should Branch

EQ_LABEL:
ADD R8, R8, R1    // R8 = R8 + R1 (0x0000 + 0x0001 = 0x0001)
GT_LABEL:
ADD R8, R8, R1    // R8 = R8 + R1 (0x0002 + 0x0001 = 0x0003)
LT_LABEL:
ADD R8, R8, R1    // R8 = R8 + R1 (0x0003 + 0x0001 = 0x0004)

// Unconditional Branch
B 111, END_LABEL  // Should Always Branch

// Overflow Branch
ADD R8, R8, R8    // Overflow Test
B 110, OFL_LABEL  // Branch if Overflow - Should Branch if Overflow

OFL_LABEL:
ADD R8, R8, R1    // Overflow handler (if branched)

END_LABEL:
HLT               // Halt execution
