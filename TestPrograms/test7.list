    // Load values into registers for arithmetic operations
    LLB R1, 0x10      // R1 = 0x0010
    LHB R1, 0x00      
    LLB R2, 0x20      // R2 = 0x0020
    LHB R2, 0x00
    LLB R3, 0x05      // R3 = 0x0005
    LHB R3, 0x00
    LLB R4, 0xFF      // R4 = 0x00FF
    LHB R4, 0x00
    LLB R5, 0x01      // R5 = 0x0001
    LHB R5, 0x00
    LLB R6, 0x04      // R6 = 0x0004
    LHB R6, 0x00
    LLB R7, 0x00      // R7 = 0x0000
    LHB R7, 0x00

    // Memory-to-Memory Forwarding (LW followed by SW)
    LW  R8, R1, 0x04  // Load memory at address R1 + 0x04 into R8
    SW  R8, R1, 0x08  // Store R8 at address R1 + 0x08 (forwarding)

    // Arithmetic operations
    ADD R9, R1, R2    // R9 = R1 + R2
    SUB R10, R2, R3   // R10 = R2 - R3
    PADDSB R11, R9, R10 // Packed add signed bytes

    // Bitwise and Shift operations
    SLL R12, R9, R5   // Logical shift left
    SRA R13, R10, R5  // Arithmetic shift right
    ROR R14, R12, R6  // Rotate right

    // Reduction Unit (RED)
    RED R15, R14, R13, // Reduction operation (complex)

    // Branch and Jump tests
    PCS R16           // Save PC in R16
    B 011, branch1    // Branch if Less Than (N=1)
    BR 111, R16       // Unconditional jump to saved PC (loop)

    // Hazard Tests
    ADD R17, R9, R8   // Dependent on forwarded result from LW
    SUB R18, R17, R4  // Dependent on previous ADD
    SLL R19, R18, R5  // Dependent on previous SUB

    // Branch target
branch1:
    ADD R20, R7, R7   // R20 = 0 (used for verification)
    PCS R21           // Save PC in R21 for check
    HLT               // End of program
